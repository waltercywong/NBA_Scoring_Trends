"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.Graphic = exports.log = void 0;
const rxjs_1 = require("rxjs");
const operators_1 = require("rxjs/operators");
const d3_scale_1 = require("d3-scale");
const log = (...args) => (data) => {
    console.log.apply(null, args.concat([data]));
    return data;
};
exports.log = log;
class Graphic {
    constructor({ scenes, sceneOrder, debug, mountPoint, sceneBuffer, hiddenClass, isMobile }) {
        this.scenes = {};
        this.sceneOrder = [];
        this.headerBuffer = 50;
        this.activeSteps = [];
        this.isMounted = false;
        this.hiddenClass = "hidden-scene";
        this.cancelOnUnmount = [];
        this.scenes = scenes;
        this.hiddenClass = hiddenClass || "hidden-scene";
        this.sceneOrder = sceneOrder;
        this.resize$ = new rxjs_1.BehaviorSubject(window);
        this.screenHeight$ = new rxjs_1.BehaviorSubject(window.innerHeight - 50);
        this.fallback$ = new rxjs_1.BehaviorSubject(false);
        this.mountPoint = mountPoint;
        if (isMobile) {
            this.isMobile = true;
        }
        this.initialHeight = window.innerHeight;
        // This adds a default half screen-length buffer before and after the graphic
        this.sceneBuffer = sceneBuffer || .5;
        this.totalScreenLengths = Object.entries(scenes).map(([k, v]) => v.screenLengths + this.sceneBuffer).reduce((a, c) => a + c, 0);
        this.scrollPos$ = (0, rxjs_1.fromEvent)(document, "scroll").pipe((0, operators_1.switchMap)(x => (0, rxjs_1.of)(window.scrollY)));
        this.textPlate = document.createElement("div");
        this.vizPlate = document.createElement("div");
        // Spacer elements for before an after the graphic
        // this.b1 = document.createElement("div");
        // this.b2 = document.createElement("div");
        this.steps = this.sceneOrder.map(x => this.scenes[x])
            .reduce((a, e) => {
            let t = e.text.map(x => (Object.assign(Object.assign({}, x), { screens: a["s"] + x.screens })));
            a["s"] += e.screenLengths;
            a["t"] = [...a["t"], ...t];
            return a;
        }, { s: 0, t: [] }).t;
        // Set up scroll notification
        const anchor = document.getElementById(mountPoint);
        if (!anchor)
            throw new Error(`Cannot find mount point ${mountPoint}`);
        this.anchorPos$ = (0, rxjs_1.interval)(500).pipe((0, operators_1.map)(() => anchor.getBoundingClientRect().top + window.scrollY), (0, operators_1.distinctUntilChanged)());
        if (debug) {
            this.cancelOnUnmount.push((0, rxjs_1.fromEvent)(document, "keydown").pipe((0, operators_1.map)(e => e.keyCode), (0, operators_1.bufferCount)(10, 1), (0, operators_1.filter)(Graphic.isKonamiCode)).subscribe(v => this.setFallback(!this.fallback$.getValue())));
            // debug logging
            this.cancelOnUnmount = this.cancelOnUnmount.concat([
            // ["resize", this.resize$],
            // ["scrollPos", this.scrollPos$],
            // ["fallback", this.fallback$],
            // ["screenHeight", this.screenHeight$],
            // [`${mountPoint}-anchorPos`, this.anchorPos$]
            ].map(([name, sub]) => sub.subscribe((0, exports.log)(name))));
        }
    }
    setFallback(v) {
        this.fallback$.next(v);
    }
    mount() {
        this.initialHeight = window.innerHeight;
        if (!this.isMounted) {
            this.initializePlateStyles(this.mountPoint);
        }
        // this.screenHeight$.next(initialHeight);
        this.listenResize(this.initialHeight);
        this.attachText();
        this.attachSceneContainers();
        this.activateAllScenes();
        this.isMounted = true;
    }
    // public run(debug = false): void {
    //     if (this.isMounted) {
    //         this.activateAllScenes(debug);
    //     }
    // }
    unmount() {
        for (let sub of this.cancelOnUnmount) {
            sub.unsubscribe();
        }
    }
    attachText() {
        for (let step of this.steps) {
            if (!this.isMounted) {
                if (step.elType !== "h1") {
                    const p = document.createElement(step.elType);
                    p.classList.add("stepper-text");
                    p.innerHTML = step.text;
                    const d = document.createElement("div");
                    d.classList.add("step");
                    d.append(p);
                    this.textPlate.append(d);
                    this.activeSteps.push({
                        el: d,
                        screenLengthPos: step.screens
                    });
                }
                if (step.elType === "h1") {
                    const container = document.createElement("p");
                    container.classList.add("byline-block");
                    const b1 = document.createElement("span");
                    const b2 = document.createElement("span");
                    const d = document.createElement("span");
                    b1.classList.add("byline1");
                    b2.classList.add("byline2");
                    d.classList.add("dateline");
                    b1.innerHTML = step.byline1;
                    b2.innerHTML = step.byline2;
                    d.innerHTML = step.date;
                    container.append(b1);
                    container.append(b2);
                    container.append(d);
                    const x = document.createElement("div");
                    const h1 = document.createElement("h1");
                    h1.innerHTML = step.text;
                    x.append(h1);
                    x.append(container);
                    x.classList.add("step");
                    x.classList.add("title-step");
                    this.textPlate.append(x);
                    this.activeSteps.push({
                        el: x,
                        screenLengthPos: step.screens,
                    });
                }
            }
        }
        this.cancelOnUnmount.push(this.screenHeight$.subscribe(s => this.adjustStepheight(s)));
    }
    adjustStepheight(x) {
        // const anchor = document.getElementById(this.mountPoint).getBoundingClientRect();
        for (let step of this.activeSteps) {
            step.el.style.top = `${x * step.screenLengthPos}px`;
        }
    }
    activateAllScenes() {
        // const anchor = document.getElementById(this.mountPoint).getBoundingClientRect();
        this.sceneOrder.map((id, index) => {
            const scene = this.scenes[id];
            let offsetScreens = 0;
            if (index > 0) {
                const prevScenes = this.sceneOrder.slice(0, index);
                for (let s of prevScenes) {
                    offsetScreens += this.scenes[s].screenLengths;
                }
            }
            // offsetScreens += this.screenBuffer
            const progress$ = (0, rxjs_1.combineLatest)([this.scrollPos$, this.screenHeight$, this.anchorPos$]).pipe((0, operators_1.map)(([pos, height, anchorTop]) => {
                const totalHeight = scene.screenLengths * height;
                let s = (0, d3_scale_1.scaleLinear)().domain([anchorTop + this.headerBuffer, anchorTop + this.headerBuffer + totalHeight + height]).range([0, 1]).clamp(true);
                return s(pos);
            }), (0, operators_1.distinctUntilChanged)());
            // if (debug) {
            //     this.cancelOnUnmount = this.cancelOnUnmount.concat(
            //         [
            //             ["progress", progress$],
            //             ["anchorTop", this.anchorPos$],
            //             ["position", this.scrollPos$]
            //         ].map(([name, sub]) => (<any>sub).subscribe(log(name)))
            //     )
            // }
            scene.activate({
                resize$: this.resize$,
                screenHeight$: this.screenHeight$,
                fallback$: this.fallback$,
                progress$,
                id
            });
            this.cancelOnUnmount.push(progress$.subscribe(p => {
                if (index === 0) {
                    if (p === 1) {
                        scene.graphicContainer.classList.add(this.hiddenClass);
                    }
                    else {
                        scene.graphicContainer.classList.remove(this.hiddenClass);
                    }
                }
                else {
                    if (p === 0) {
                        scene.graphicContainer.classList.add(this.hiddenClass);
                    }
                    else {
                        scene.graphicContainer.classList.remove(this.hiddenClass);
                    }
                }
            }));
        });
    }
    attachSceneContainers() {
        this.sceneOrder.map((id, index) => {
            const scene = this.scenes[id];
            if (!this.isMounted) {
                scene.graphicContainer.classList.add(`${id}-viz`);
                scene.graphicContainer.classList.add("viz");
                scene.graphicContainer.style.zIndex = `${100 - index}`;
                this.vizPlate.append(scene.graphicContainer);
            }
            scene.mount({ vizPlate: scene.graphicContainer });
        });
    }
    listenResize(initialHeight) {
        this.cancelOnUnmount.push(this.resize$.subscribe(x => {
            // if (x.innerHeight > initialHeight && x.innerHeight - initialHeight <= 60) {
            //     this.vizPlate.style.marginTop = `${x.innerHeight - initialHeight}px`;
            // } else if (x.innerHeight == initialHeight) {
            //     this.vizPlate.style.marginTop = "0px";
            // }
            return this.isMobile ?
                this.screenHeight$.next(Math.abs(x.innerHeight - initialHeight) <= 60 ? initialHeight : x.innerHeight)
                : this.screenHeight$.next(this.initialHeight);
        }));
        this.cancelOnUnmount.push((0, rxjs_1.fromEvent)(window, "resize").pipe((0, operators_1.debounceTime)(100), (0, operators_1.map)(e => e.target)).subscribe(this.resize$));
        this.cancelOnUnmount.push(this.screenHeight$.subscribe(x => {
            this.textPlate.style.height = `${x * this.totalScreenLengths}px`;
            this.vizPlate.style.height = `${x}px`;
            // this.b1.style.height = `${x * this.sceneBuffer}`
            // this.b2.style.height = `${x * this.sceneBuffer}`
        }));
    }
    initializePlateStyles(id) {
        const m = document.getElementById(id);
        this.vizPlate.classList.add("viz-plate");
        this.textPlate.classList.add("text-plate");
        m.appendChild(this.vizPlate);
        m.appendChild(this.textPlate);
    }
    static isKonamiCode(buffer) {
        return [38, 38, 40, 40, 37, 39, 37, 39, 66, 65].toString() === buffer.toString();
    }
}
exports.Graphic = Graphic;
//# sourceMappingURL=Graphic.js.map