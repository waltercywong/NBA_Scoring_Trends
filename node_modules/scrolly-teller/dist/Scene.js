"use strict";
// noinspection JSUnusedGlobalSymbols
Object.defineProperty(exports, "__esModule", { value: true });
exports.VideoScene = exports.StageScene = exports.Stage = exports.step = void 0;
const rxjs_1 = require("rxjs");
const d3_1 = require("d3");
const operators_1 = require("rxjs/operators");
// Decorator function
function step(id) {
    return function (target, propertyKey) {
        target.fmap = target.fmap || {};
        target.fmap[id] = propertyKey;
    };
}
exports.step = step;
class Stage {
    constructor(p) {
        this.screens = p.steps[p.steps.length - 1].screenLengthPos;
        this.stageProgress$ = new rxjs_1.BehaviorSubject("init");
        this.steps = p.steps;
    }
    activate(params) {
        let subs = [];
        const { state } = params;
        subs.push((0, rxjs_1.combineLatest)([params.stageProgress$.pipe((0, operators_1.distinctUntilChanged)()), params.resize$])
            .subscribe(([p, r]) => {
            try {
                this[Object.getPrototypeOf(this).fmap[p]](r, { state });
            }
            catch (e) {
                console.error(e);
                console.error(`no fmap for id ${p}`);
            }
        }));
        return subs;
    }
    mount(p) {
        return p;
    }
}
exports.Stage = Stage;
class StageScene {
    constructor(p) {
        this.screenLengths = 0;
        this.steps = [];
        this.screenLengths = p.screenLengths;
        this.stages = p.stages;
        this.stageOrder = p.stageOrder;
        this.graphicContainer = document.createElement("div");
        this.graphicContainer.style.width = "100%";
        this.graphicContainer.style.height = "100%";
        this.graphicContainer.style.position = "absolute";
        this.graphicContainer.style.top = "0";
        this.graphicContainer.style.left = "0";
        this.initStages();
    }
    activate(params) {
        let subs = [];
        for (let stage of Object.values(this.stages)) {
            subs = [
                ...subs,
                ...stage.activate(Object.assign(Object.assign({}, params), { stageProgress$: stage.stageProgress$, state: this.state }))
            ];
        }
        // If we generalize this class to just pass a state value, resizing the svg must be done by the subclass
        //
        // subs.push(params.resize$.subscribe(r => {
        //     this.selections.svg.attr("width", `${r.innerWidth}px`);
        //     this.selections.svg.attr("height", `${r.innerHeight}px`);
        // }));
        subs.push(params.progress$.pipe((0, operators_1.debounceTime)(params.progressDebounceMilli || 100)).subscribe(p => {
            const currentScreen = p * (this.screenLengths) - .5; // Move it half a screenlength so the scene triggers as the text reaches the center
            if (currentScreen < .01) {
                for (let stage of Object.values(this.stages)) {
                    stage.stageProgress$.next("init");
                }
            }
            else {
                let v = this.steps.reduce(({ current }, step) => {
                    if (currentScreen >= step.screenLengthPos) {
                        return { current: step };
                    }
                    return { current };
                }, { current: this.steps[0] }).current;
                v.stage.stageProgress$.next(v.id);
            }
        }));
        return subs;
    }
    mount(params) {
        const svg = (0, d3_1.select)(params.vizPlate).append("svg");
        this.state["selections"] = { svg };
        for (let id of this.stageOrder) {
            let stage = this.stages[id];
            let { state } = stage.mount({
                state: this.state,
            });
            this.state = state;
        }
    }
    deactivate(subs) {
        for (let sub of subs) {
            sub.unsubscribe();
        }
    }
    initStages() {
        var _a;
        // Space stages
        for (let i = 0; i < this.stageOrder.length; i++) {
            let stage = this.stages[this.stageOrder[i]];
            if (i === 0) {
                stage.start = 0;
                stage.end = stage.screens;
            }
            else if (i === this.stageOrder.length - 1) {
                stage.end = this.screenLengths;
                stage.start = ((_a = this.stages[this.stageOrder[i - 1]]) === null || _a === void 0 ? void 0 : _a.end) || 0;
            }
            else {
                let prev = this.stageOrder.slice(i);
                stage.start = prev.reduce((x, y) => {
                    return x + this.stages[y].screens;
                }, 0);
                stage.end = stage.start + stage.screens;
            }
        }
        // Offset stages
        for (let i = 0; i < this.stageOrder.length; i++) {
            let stage = this.stages[this.stageOrder[i]];
            let offset = 0;
            for (let ii of this.stageOrder.slice(0, i)) {
                const pstage = this.stages[ii];
                offset += 1 + pstage.steps[pstage.steps.length - 1].screenLengthPos;
            }
            for (let step of stage.steps) {
                this.steps.push({ screenLengthPos: step.screenLengthPos + offset, stage, id: step.id });
            }
        }
    }
}
exports.StageScene = StageScene;
class VideoScene {
    constructor(p) {
        this.screenLengths = 0;
        this.lastDrawn$ = new rxjs_1.BehaviorSubject(0);
        this.lastToDraw$ = new rxjs_1.BehaviorSubject([]);
        this.drain$ = new rxjs_1.BehaviorSubject(0);
        this.remainder$ = new rxjs_1.BehaviorSubject([]);
        this.isMounted = false;
        this.isMobile = false;
        this.pinClass = "pinned";
        this.pinZero = false;
        this.vidEl = p.vidEl;
        this.framerate = p.framerate;
        this.screenLengths = p.screenLengths;
        this.frameStepsDesktop = p.frameStepsDesktop;
        this.frameStepsMobile = p.frameStepsMobile;
        // this.steps = p.steps;
        this.numFrames = p.numFrames;
        this.isMobile = p.isMobile;
        if (p.pinZero) {
            this.pinZero = true;
        }
        this.timeupdate$ = (0, rxjs_1.fromEvent)(this.vidEl, "timeupdate");
        this.graphicContainer = document.createElement("div");
        this.text = p.text.map(x => (Object.assign(Object.assign({}, x), { screens: +x.screens })));
        this.graphicContainer.classList.add("vid-container");
        this.graphicContainer.classList.add(this.isMobile ? "mobile-vid" : "desktop-vid");
        if (this.pinZero) {
            this.graphicContainer.classList.add(this.pinClass);
        }
        for (let el of [this.graphicContainer]) {
            el.style.width = "100%";
        }
        this.graphicContainer.append(this.vidEl);
    }
    activate(params) {
        let subs = [];
        params.progress$.subscribe(p => {
            if (p > 0 && p < 1) {
                this.graphicContainer.classList.add(this.pinClass);
                this.graphicContainer.classList.remove(`not-${this.pinClass}`);
            }
            if (p === 0) {
                if (this.pinZero) {
                    this.graphicContainer.classList.add(this.pinClass);
                    this.graphicContainer.classList.remove(`not-${this.pinClass}`);
                }
                else {
                    this.graphicContainer.classList.remove(this.pinClass);
                    this.graphicContainer.classList.add(`not-${this.pinClass}`);
                }
            }
            else if (p === 1) {
                // TODO: different class to pin to bottom?
                this.graphicContainer.classList.remove(this.pinClass);
                this.graphicContainer.classList.add(`not-${this.pinClass}`);
            }
        });
        let timesToDraw$ = params.progress$.pipe((0, operators_1.throttleTime)(100), (0, operators_1.distinctUntilChanged)(), (0, operators_1.withLatestFrom)(this.lastDrawn$), (0, operators_1.switchMap)(([scrollPct, lastDrawn]) => {
            const steps = this.isMobile ? this.frameStepsMobile : this.frameStepsDesktop;
            const targetFrame = this.numFrames * scrollPct;
            const frameDiff = (targetFrame - lastDrawn) / steps;
            const times = [];
            for (let i = 1; i < steps + 1; i++) {
                times.push(lastDrawn + (i * frameDiff));
            }
            return (0, rxjs_1.of)(times);
        }));
        this.timeupdate$.pipe((0, operators_1.debounceTime)(20), (0, operators_1.withLatestFrom)(timesToDraw$, this.lastToDraw$, this.remainder$)).subscribe(([_, t, l, r]) => {
            // console.log({t, l, r})
            // If t and l are the same, continue to drain r
            if (JSON.stringify(t) === JSON.stringify(l)) {
                const d = r.shift();
                this.drain$.next(d);
                // If remainders is drained, repopulate with last value so that "timeupdate" keeps ticking
                this.remainder$.next(r);
                // Else, set l = t, r = t, and drain the first of t
            }
            else {
                this.remainder$.next(t.slice(1));
                this.lastToDraw$.next(t);
                this.drain$.next(t[0]);
            }
        });
        this.drain$.subscribe(this.update.bind(this));
        subs.push(params.progress$.pipe((0, operators_1.throttleTime)(1000)).subscribe(_ => this.vidEl.dispatchEvent(new Event("timeupdate"))));
        return subs;
    }
    update(t) {
        // If this frame hasn't been drawn yet, draw it
        if (t && t !== this.vidEl.currentTime) {
            this.vidEl.currentTime = t / this.framerate;
            this.lastDrawn$.next(t);
        }
        else {
            // Otherwise kick the engine again so it turns over next frame
            setTimeout(() => this.vidEl.dispatchEvent(new Event("timeupdate")));
        }
    }
    mount(params) {
        if (!this.isMounted) {
            params.vizPlate.append(this.vidEl);
            this.vidEl.pause();
        }
        this.isMounted = true;
    }
    deactivate(subs) {
        for (let sub of subs) {
            sub.unsubscribe();
        }
    }
}
exports.VideoScene = VideoScene;
//# sourceMappingURL=Scene.js.map